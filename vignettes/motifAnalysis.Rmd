---
title: "Motif Analysis Using motifTestR"
author:
- name: Stevie Pederson
  affiliation: Black Ochre Data Labs, Telethon Kids Institute
  email: stephen.pederson@telethonkids.org.au
package: motifTestR
bibliography: '`r system.file("references.bib", package = "motifTestR")`'
output:
  BiocStyle::html_document
abstract: |
  Analysis of transcription factor binding motifs using Position Weight Matrices
  (PWMs) is a common task in analysis of genomic data.
  Two key tests for analysis of TFBMs using morifTestR are demonstrated below
vignette: |
  %\VignetteIndexEntry{Motif Analysis Using motifTestR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(message = FALSE, crop = NULL)
```


# Introduction

Bioinformatic analysis of data from ChIP-Seq and ATAC-Seq commonly involves the analysis of sequences within the regions identified is being of interest.
Whilst these analyses are not restricted to transcription factors, this can 
often form an important component of this type of analysis.
Analysis of Transcription Factor Binding Motifs (TFBMs) is often performed 
using Position Weight Matrics (PWMs) to encode the flexibility in which exact sequence is bound by the particular transcription factor.

Managing of TFBMs is well supported in `R` with `r Biocpkg("MotifDb")` providing
a wide database of PWMs as provided by multiple databases.
Additional, both `r Biocpkg("TFBSTools")` [@Tan2016-lj] and `r Biocpkg("universalmotif")` enable the import and management of a wide variety 
of TFBM formats which are able to be sourced directly from HOCOMOCO [@Kulakovskiy2013-jt], JASPAR [@Sandelin2004-mv] or any other source, or even 
custom databases determined experimentally.
Visualisation of TFBMs is also well supported in the Bioconductor ecosystem via `r Biocpkg("motifStack")` [@ou2018], `r Biocpkg("TFBSTools")` and 
`r Biocpkg("seqLogo")`, with good analytic capability also provided by 
`r Biocpkg("monaLisa")` [@Machlab2022-rg] and `r Biocpkg("PWMEnrich")`.

Many tools provide analytic capability outside of R, such as HOMER [@Heinz2010-dz] 
and the MEME-Suite [@Bailey2015-wa], which are both widely used to ask varied 
questions of the data, including motif enrichment, positional enrichment and identification of novel TFBMs. 
The package `r Biocpkg("memes")` provides an R wrapper to several of the tools 
within the MEME-suite, whilst `r Githubpkg("robertamezquita/marge")` provides a wrapper to HOMER.
However, both of these require the external tools to be installed.

The tools within `motifTestR` aim to build on and expand the existing resources 
available to the Bioconductor community, and offer two complementary approaches
to TFBM analysis within `XStringSet` objects containing multiple sequences.


# Setup

## Installation

In order to perform the operations in this vignette, the following packages 
require installation.

```r 
if (!"BiocManager" %in% rownames(installed.packages()))
  install.packages("BiocManager")
BiocManager::install("motifTestR")
```

Once installed, we can load the required packages

```{r load-packages}
library(motifTestR)
library(extraChIPs)
library(rtracklayer)
library(BSgenome.Hsapiens.UCSC.hg19)
library(parallel)
library(dplyr)
library(ggplot2)
library(patchwork)
theme_set(theme_bw())
```

```{r}
cores <- 1
```


## Defining a Set of Peaks

The peaks used in this workflow were obtained from the bed files denoting binding sites of the Androgen Receptor and Estrogen Receptor, which are also marked by
H3K27ac, in ZR-75-1 cells under DHT treatment [@Hickey2021-mz].
A subset of 479 peaks, resized to 400bp from chromosome1 can be loaded using the following.

```{r load-examle-peaks}
data("ar_er_peaks")
ar_er_peaks
sq <- seqinfo(ar_er_peaks)
```

Whilst the example dataset is small for the conveneience of an R package, those wishing to work on the complete set of peaks (i.e. not just chromosome 1) may run the following code to obtain all peaks.
This will produce a higher number of significant results in subsequent analyses and will increase run times for all functions.

```r
## Not run
base_url <- "https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM3511nnn"
bed_url <- list(
  AR = file.path(
    base_url, "GSM3511083/suppl/GSM3511083%5FAR%5Fpeaks%5FED.bed.gz"
  ),
  ER = file.path(
    base_url, "GSM3511085/suppl/GSM3511085%5FER%5Fpeaks%5FED.bed.gz"
  ),
  H3K27ac = file.path(
    base_url, "GSM3511087/suppl/GSM3511087%5FH3K27ac%5Fpeaks%5FED.bed.gz"
  )
)
all_peaks <- GRangesList(lapply(bed_url, import.bed))
seqlevels(all_peaks) <- seqnames(sq)
seqinfo(all_peaks) <- sq
## Return the ranges with coverage from 2 or more targets
ar_er_peaks <- makeConsensus(
  all_peaks, p = 2/3, method = "coverage", min_width = 200
) |>
  ## Now subset to the ranges which overlap a peak from every target
  subset(n == 3) |> 
  resize(width = 400, fix = 'center')
```

## Obtaining a Set of Sequences for Testing

Now that we have genomic co-ordinates as a set of peaks, we can obtain the sequences that are associated with each peak.
The source ranges can also be added to the sequences as names by coercing the ranges to a character vector

```{r test-seq}
test_seq <- getSeq(BSgenome.Hsapiens.UCSC.hg19, ar_er_peaks)
names(test_seq) <- as.character(ar_er_peaks)
```

## Obtaining a List of PWMs for Testing

A small list of PWMs, obtained from `r Biocpkg("MotifDb")` are provided with the package and these will be suitable for all downstream analysis.
For those wishing to use their own data, please choose a set of PWMs by parsing files using `r Biocpkg("universalmotif")` or subsetting those in `MotifDb` down to a suitable size.

```{r ex-pwm}
data("ex_pwm")
names(ex_pwm)
```

Again, a larger set of motifs may be obtained using following code, or by customising query fields as preferred.

```r
## Not run
library(MotifDb)
ex_pwm <- MotifDb |>
  subset(organism == "Hsapiens") |>
  query("HOCOMOCOv11-core-A") |>
  as.list() 
names(ex_pwm) <- gsub(".+HOCOMOCOv11-core-A-(.+)_.+", "\\1", names(ex_pwm))
```


# Searching Sequences

## Finding PWM Matches

All PWM matches within the test sequences can be returned for any of the PWMs,
with `getPwmMatches()` searching using the PWM and it's reverse complement by 
default.

```{r match-esr1}
getPwmMatches(ex_pwm$ESR1, test_seq)
```

Many sequences will contain multiple matches, and we can subset our results to only the 'best match' by setting `best_only = TRUE`.
The best match is chosen by the highest score returned for each match.
If multiple matches return identical scores, one is chosen at random by default.
This can be further controlled by setting `break_ties` to any of c("random", "first", "last", "central", "all"), which will choose by sequence order, proximity to centre, or all tied matches if preferred.

```{r best-match-esr1}
getPwmMatches(ex_pwm$ESR1, test_seq, best_only = TRUE)
```

We can return all best matches for each PWM, by passing the complete list of PWMs.

```{r bm-all}
bm_all <- getPwmMatches(
  ex_pwm, test_seq, best_only = TRUE, break_ties = "all",
  mc.cores = cores
)
```

This same strategy of passing a single, or multiple PWMs can be applied even when simply wishing to count the total matches for each PWM.
Counting may be useful for restricting downstream analysis to the set of motifs with more than a given number of matches.

```{r count-pwm-matches}
countPwmMatches(ex_pwm, test_seq, mc.cores = cores)
```


# Analysis of Positional Bias

## Testing for Positional Bias

A common tool within MEME-Suite is `centrimo` [@Bailey2012-qz] and `motifTestR` provides a simple, easily interpretable alternative using `testMotifPos()`.
This function bins the distances from the centre of each sequence and, if no positional bias is expected (i.e. H~0~), matches should be equally distributed between bins.

A test within each bin is performed using `binom.test()` and a summarised p-value for all tests is returned using the asymptotically exact harmonic mean p-value [@Wilson2019-ln].
By default, the binomial test is applied for the null hypothesis to detect matches in each bin which are *greater* than expected, however, this can also be set by the user.
When using the harmonic-mean p-value however, this tends return a more conservative p-value across the entire set of bins.


```{r test-motif-pos}
res_pos <- testMotifPos(matches = bm_all, mc.cores = cores) |>
  arrange(p)
head(res_pos)
```

The bins returned by the function represent the widest range of bins where the raw p-values were below the harmonic-mean p-value.
Wide ranges tend to be associated with lower significance for that PWM.

Due to the two-stranded nature of DNA, the distance from zero cn also be assessed by setting `abs = TRUE` and in this case the first bin begins at zero.

```{r test-motif-pos-abs}
res_abs <- testMotifPos(matches = bm_all, abs = TRUE, mc.cores = cores) |>
  arrange(p) 
head(res_abs)
```

This approach is particularly helpful for detecting co-located transcription factors which can be any distance from the TF which was used to obtain and centre the test set of sequences.

## Viewing Matches

The complete set of matches returned as a list above can be simply passed to `ggplot2` for visualisation, in order to asses whether any PWM appears to have a positional bias.
By default, smoothed values across all motifs will be overlaid (Figure \@ref(fig:plot-pos)A), however, tailoring using ggplot is simple to produce a wide variety of outputs (Figure \@ref(fig:plot-pos)B)

```{r plot-pos, fig.cap = "Distribution of motif matches around the centres of the set of peaks"}
topMotifs <- rownames(res_pos)[1:4]
A <- plotMatchPos(bm_all[topMotifs], binwidth = 10, se = FALSE)
B <- plotMatchPos(bm_all[topMotifs], binwidth = 10, geom = "col") +
  geom_smooth(se = FALSE, show.legend = FALSE) +
  facet_wrap(~name)
A + B + plot_annotation(tag_levels = "A") & theme(legend.position = "bottom")
```

Whilst the above will produce figures showing the symmetrical distribution around the peak centres, the distance from the peak centre can also be shown as an absolute distance.
In Figure \@ref(fig:plot-abs-pos) distances shown as a heatmap (A) or as a CDF (B).
The latter makes it easy to see that 50% of ESR1 matches occur within a short distance of the centre (~30bp), whilst for ANDR and FOXA1, this distance is roughly doubled.
Changing the binwidth argument can either smooth data or increase the fine resolution.


```{r plot-abs-pos, fig.cap = "Distribution of motif matches shown as a distance from the centre of each sequence"}
topMotifs <- rownames(res_abs)[1:4]
A <- plotMatchPos(bm_all[topMotifs], abs = TRUE, type = "heatmap") +
  scale_fill_viridis_c()
B <- plotMatchPos(
  bm_all[topMotifs], abs = TRUE, type = "cdf", geom = "line", binwidth = 5
)
A + B + plot_annotation(tag_levels = "A") & theme(legend.position = "bottom")
```


# Testing For Motif Enrichment

As well as providing methods for analysing positional bias within a set of PWM matches, methods to test for enrichment are also implemented
A common approach when testing for motif enrichment is to obtain a set of random or background sequences which represent a suitable control set to define the null hypothesis (H~0~).
In `motifTestR`, two alternatives are offered utilising this approach, which both return similar results but involve different levels of computational effort.

The first approach is to sample multiple sets of background sequences and by 'iterating' through to obtain a null distribution for PWM matches and comparing our observed counts against this distribution.
It has been noticed that this approach commonly produces a set of counts for H~0~ which closely resemble a Poisson distribution, and a second approach offered in `motifTestR` is to sample a suitable large set of background sequences and estimate the parameters for the Poisson distribution for each PWM, and testing against these.

## Defining a Set of Control Sequences

Choosing a suitable set of control sequences can be undertaken by any number of methods.
`motifTestR` enables a strategy of matching sequences by any number of given features.
The data object `zr75_enh` contains the candidate enhancers for ZR-75-1 cells defined by v2.0 of the Enhancer Atlas [@gao2019], for chromosome 1 only.
A high proportion of our peaks are associated with these regions and choosing control sequences based a similar proportion of these regions may be a viable strategy.

```{r zr75-enh}
data("zr75_enh")
mean(overlapsAny(ar_er_peaks, zr75_enh))
```

``` r
## Not run
zr75_enh <- import.bed("http://www.enhanceratlas.org/data/download/enhancer/hs/ZR75-1.bed")
zr75_enh <- granges(zr75_enh)
seqlevels(zr75_enh) <- seqnames(sq)
seqinfo(zr75_enh) <- sq
mean(overlapsAny(ar_er_peaks, zr75_enh))
```


```{r}
ar_er_peaks$feature <- ifelse(
  overlapsAny(ar_er_peaks, zr75_enh), "enhancer", "other"
)
bg_ranges <- GRangesList(
  enhancer = zr75_enh,
  other = GenomicRanges::setdiff(GRanges(sq)[1], zr75_enh)
)
```

```{r}
data("hg19_mask")
set.seed(305)
rm_ranges <- makeRMRanges(
  splitAsList(ar_er_peaks, ar_er_peaks$feature),
  bg_ranges, exclude = hg19_mask,
  n_iter = 100
)
```

This gives a set of control ranges which are randomly-selected (R) size-matched (M) to our peaks and are drawn from a similar distribution of genomic features.
By setting `n_iter = 100`, this set will be 100 times larger than our test set and typically this value can be set to 1000 or even 5000 for better estimates of parameters under the null distribution.

```{r}
rm_seq <- getSeq(BSgenome.Hsapiens.UCSC.hg19, rm_ranges)
mcols(rm_seq) <- mcols(rm_ranges)
```

## Testing For Enrichment

```{r}
enrich_res <- testMotifEnrich(ex_pwm, test_seq, rm_seq, mc.cores = cores) |>
  arrange(p)
enrich_res |> head()
```

```{r}
testMotifEnrich(ex_pwm, test_seq, rm_seq, mc.cores = cores, model = "iter")
```

```{r plot-overlaps, fig.cap = "Distribution of PWM matches within sequences. Each sequence is only considered once and as such, match numbers may be below those returned during testing, which includes multiple matches within a sequence."}
topMotifs <- rownames(enrich_res)[1:4]
ex_pwm[topMotifs] |>
  getPwmMatches(test_seq) |>
  lapply(\(x) x$seq) |>
  plotOverlaps(type = "upset")
```

# Appendix

Vignettes are commonly prepared for compiling with limited resources and as such example datasets and analyses may less informative.
For more comprehensive analysis the following three chunks will allow analysis of the above dataset, but without being restricted to chromosome 1



# References {.unnumbered}


# Session info

```{r sessionInfo, echo=FALSE}
sessionInfo()
```
